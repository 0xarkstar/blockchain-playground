{
  "common": {
    "title": "Blockchain Playground",
    "subtitle": "Interactive blockchain education platform",
    "getStarted": "Get Started",
    "viewAll": "View All",
    "demo": "Demo",
    "theory": "Theory",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "connectWallet": "Connect Wallet",
    "darkMode": "Dark Mode",
    "lightMode": "Light Mode",
    "language": "Language",
    "progress": {
      "completed": "Completed",
      "of": "of",
      "markComplete": "Mark Complete",
      "markedComplete": "Completed!",
      "stepOf": "Step {current} of {total}"
    },
    "nav": {
      "previous": "Previous",
      "next": "Next",
      "backToTrack": "Back to {track}",
      "startLearning": "Start Learning",
      "continueLearning": "Continue Learning"
    }
  },
  "home": {
    "hero": {
      "title": "Learn Blockchain by Doing",
      "description": "Master blockchain concepts through interactive demos, live visualizations, and hands-on smart contract deployment.",
      "cta": "Start Learning",
      "ctaContinue": "Continue: {demo}"
    },
    "tracks": {
      "title": "Learning Tracks",
      "description": "Choose your learning path",
      "startHere": "Start Here",
      "trackNumber": "Track {number}"
    }
  },
  "tracks": {
    "fundamentals": {
      "title": "Blockchain Fundamentals",
      "description": "Hashing, blocks, consensus, Merkle trees, transactions, wallets, and state management",
      "demos": "11 Interactive Demos",
      "modules": "7 Education Modules"
    },
    "defi": {
      "title": "DeFi",
      "description": "Swaps, liquidity pools, lending, staking, flash loans, oracles, and yield farming",
      "demos": "11 Interactive Demos",
      "modules": "11 Interactive Demos"
    },
    "solidity": {
      "title": "Solidity",
      "description": "Storage layout, proxies, reentrancy, gas optimization, assembly, and access control",
      "demos": "11 Interactive Demos",
      "modules": "11 Interactive Demos"
    },
    "tokens": {
      "title": "Tokens & NFTs",
      "description": "ERC-20, ERC-721, ERC-1155, marketplaces, auctions, vesting, and royalties",
      "demos": "11 Interactive Demos",
      "modules": "11 Interactive Demos"
    },
    "zk": {
      "title": "ZK Proofs",
      "description": "Zero-knowledge proofs, circuits, on-chain verification, and privacy protocols",
      "demos": "11 Interactive Demos",
      "modules": "11 Interactive Demos"
    },
    "appliedZk": {
      "title": "Applied ZK",
      "description": "Real zero-knowledge proofs with snarkjs, Circom circuits, and on-chain verification",
      "demos": "11 Interactive Demos",
      "modules": "8 Education Modules"
    }
  },
  "fundamentals": {
    "pageTitle": "Blockchain Fundamentals",
    "pageDescription": "Master the building blocks of blockchain technology through interactive demos and theory modules.",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "demos": {
      "hashExplorer": {
        "title": "Hash Explorer",
        "description": "Explore SHA-256, Keccak-256, and BLAKE2b hashing with avalanche effect visualization"
      },
      "signatureStudio": {
        "title": "Digital Signature Studio",
        "description": "Generate secp256k1 keys, sign messages, and verify signatures"
      },
      "blockBuilder": {
        "title": "Block Builder",
        "description": "Create transactions, build Merkle trees, and mine blocks with adjustable PoW"
      },
      "chainIntegrity": {
        "title": "Chain Integrity",
        "description": "Build a blockchain and watch cascade failures when blocks are tampered"
      },
      "merkleProof": {
        "title": "Merkle Proof Verifier",
        "description": "Build Merkle trees, generate proofs, and verify them on-chain"
      },
      "miningSimulator": {
        "title": "Mining Simulator",
        "description": "PoW mining with adjustable difficulty, hash rate metrics, and Web Worker"
      },
      "transactionBuilder": {
        "title": "Transaction Builder",
        "description": "Build, sign, and broadcast real transactions on Base Sepolia"
      },
      "walletWorkshop": {
        "title": "Wallet Workshop",
        "description": "BIP39 mnemonic generation, BIP32 HD derivation, and BIP44 paths"
      },
      "consensusPlayground": {
        "title": "Consensus Playground",
        "description": "Multi-node PoW/PoS simulation with fork creation and resolution"
      },
      "stateExplorer": {
        "title": "State Explorer",
        "description": "Browse Ethereum state trie, account data, storage slots, and state proofs"
      },
      "gasEstimator": {
        "title": "Gas Estimator",
        "description": "Estimate gas for various operations and compare costs"
      }
    }
  },
  "defi": {
    "pageTitle": "DeFi",
    "pageDescription": "Explore decentralized finance through interactive simulations — AMM swaps, lending, flash loans, oracles, and yield strategies.",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "demos": {
      "simpleSwap": {
        "title": "Simple Swap",
        "description": "Constant product AMM (x*y=k) swap simulator with price impact, slippage, and fee calculations"
      },
      "liquidityPool": {
        "title": "Liquidity Pool",
        "description": "Add and remove liquidity, mint LP tokens, and track pool share percentages"
      },
      "impermanentLoss": {
        "title": "Impermanent Loss",
        "description": "Visualize impermanent loss with price ratio slider and HODL vs LP comparison"
      },
      "lendingProtocol": {
        "title": "Lending Protocol",
        "description": "Supply collateral, borrow assets, and monitor health factor and liquidation price"
      },
      "interestRateExplorer": {
        "title": "Interest Rate Explorer",
        "description": "Explore utilization-to-interest-rate curves with linear, kinked, and exponential models"
      },
      "stakingRewards": {
        "title": "Staking Rewards",
        "description": "Stake tokens, earn rewards over time, and compare APR vs APY with compounding"
      },
      "flashLoan": {
        "title": "Flash Loan",
        "description": "Simulate atomic borrow-arbitrage-repay transactions with fee calculation and revert logic"
      },
      "arbitrageSimulator": {
        "title": "Arbitrage Simulator",
        "description": "Find price discrepancies between two pools and calculate profit after gas costs"
      },
      "oraclePriceFeed": {
        "title": "Oracle Price Feed",
        "description": "Calculate TWAP, detect price deviations, and monitor oracle heartbeat freshness"
      },
      "liquidationSimulator": {
        "title": "Liquidation Simulator",
        "description": "Simulate collateral price crashes, health factor drops, and liquidation bonus calculations"
      },
      "yieldCalculator": {
        "title": "Yield Calculator",
        "description": "Compare compounding frequencies, convert APR to APY, and model yield farming strategies"
      }
    }
  },
  "solidity": {
    "pageTitle": "Solidity Deep Dive",
    "pageDescription": "Explore Solidity internals through interactive simulations — storage layout, ABI encoding, proxies, gas optimization, and EVM assembly.",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "demos": {
      "storageLayout": {
        "title": "Storage Layout",
        "description": "Visualize how Solidity packs state variables into 32-byte storage slots with optimal ordering"
      },
      "abiEncoder": {
        "title": "ABI Encoder",
        "description": "Encode function calls and decode calldata with function selectors and parameter encoding"
      },
      "dataTypes": {
        "title": "Data Types",
        "description": "Explore Solidity value types — their byte sizes, ranges, and hex representations"
      },
      "accessControl": {
        "title": "Access Control",
        "description": "Simulate role-based permissions with Ownable and AccessControl patterns"
      },
      "gasOptimizer": {
        "title": "Gas Optimizer",
        "description": "Compare gas costs of storage vs memory, packed vs unpacked, and other optimization patterns"
      },
      "eventLogInspector": {
        "title": "Event Log Inspector",
        "description": "Build event definitions and see how topics, indexed params, and data are encoded in logs"
      },
      "dataLocations": {
        "title": "Data Locations",
        "description": "Compare storage, memory, calldata, and stack — persistence, mutability, and gas costs"
      },
      "contractInteractions": {
        "title": "Contract Interactions",
        "description": "Simulate call, delegatecall, and staticcall with msg.sender and storage context visualization"
      },
      "reentrancyAttack": {
        "title": "Reentrancy Attack",
        "description": "Step-by-step visualization of a reentrancy exploit and ReentrancyGuard defense"
      },
      "proxyPatterns": {
        "title": "Proxy Patterns",
        "description": "Explore Transparent, UUPS, and Diamond proxy patterns with delegatecall visualization"
      },
      "assemblyPlayground": {
        "title": "Assembly Playground",
        "description": "Execute EVM opcodes on a simulated stack machine with step-by-step visualization"
      }
    }
  },
  "tokens": {
    "pageTitle": "Tokens & NFTs",
    "pageDescription": "Explore token standards, NFT mechanics, marketplaces, auctions, vesting, governance, and royalties through interactive simulations.",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "demos": {
      "erc20Creator": {
        "title": "ERC-20 Token Creator",
        "description": "Create fungible tokens with mint, burn, and transfer operations on a simulated ERC-20 contract"
      },
      "tokenAllowance": {
        "title": "Token Allowance Flow",
        "description": "Visualize the approve and transferFrom pattern with owner, spender, and recipient roles"
      },
      "erc721Minter": {
        "title": "ERC-721 NFT Minter",
        "description": "Mint NFTs with metadata, transfer ownership, and track token balances per address"
      },
      "erc1155MultiToken": {
        "title": "ERC-1155 Multi-Token",
        "description": "Manage fungible and non-fungible tokens in a single contract with batch transfers"
      },
      "tokenVesting": {
        "title": "Token Vesting",
        "description": "Configure linear, cliff, and graded vesting schedules with release tracking and curve visualization"
      },
      "nftMetadata": {
        "title": "NFT Metadata",
        "description": "Build ERC-721 metadata JSON with name, description, image, and attributes following OpenSea standards"
      },
      "nftMarketplace": {
        "title": "NFT Marketplace",
        "description": "List, buy, and cancel NFT listings with platform fees and royalty distribution"
      },
      "dutchAuction": {
        "title": "Dutch Auction",
        "description": "Simulate descending-price auctions with configurable start/end prices and time decay visualization"
      },
      "eip2981Royalties": {
        "title": "EIP-2981 Royalties",
        "description": "Calculate on-chain royalty payments with price breakdowns for sellers, creators, and platforms"
      },
      "tokenGovernance": {
        "title": "Token Governance",
        "description": "Create proposals, delegate voting power, cast votes, and finalize with quorum requirements"
      },
      "soulboundTokens": {
        "title": "Soulbound Tokens",
        "description": "Mint non-transferable tokens (SBTs) for identity, credentials, and reputation systems"
      }
    }
  },
  "zk": {
    "pageTitle": "ZK Proofs",
    "pageDescription": "Explore zero-knowledge proofs through interactive simulations — commitments, sigma protocols, circuits, SNARKs, rollups, and privacy.",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "demos": {
      "hashCommitment": {
        "title": "Hash Commitment",
        "description": "Commit to a secret value using hash functions, then reveal and verify without trust"
      },
      "zkConcepts": {
        "title": "ZK Proof Concepts",
        "description": "Learn completeness, soundness, and zero-knowledge through the Ali Baba Cave analogy"
      },
      "schnorrProtocol": {
        "title": "Schnorr Identification",
        "description": "Interactive sigma protocol proving knowledge of a discrete logarithm without revealing it"
      },
      "pedersenCommitment": {
        "title": "Pedersen Commitment",
        "description": "Information-theoretically hiding commitment with homomorphic addition property"
      },
      "rangeProof": {
        "title": "Range Proof",
        "description": "Prove a committed value lies in a range without revealing the value itself"
      },
      "zkSetMembership": {
        "title": "ZK Set Membership",
        "description": "Prove group membership using Merkle commitments without revealing your identity"
      },
      "arithmeticCircuits": {
        "title": "Arithmetic Circuits",
        "description": "Parse expressions into addition and multiplication gates, build R1CS constraints"
      },
      "r1csQap": {
        "title": "R1CS to QAP",
        "description": "Transform constraint matrices into polynomials and verify divisibility"
      },
      "snarkPipeline": {
        "title": "SNARK Pipeline",
        "description": "End-to-end SNARK: expression to circuit to R1CS to QAP to trusted setup to proof"
      },
      "zkRollup": {
        "title": "ZK Rollup Simulator",
        "description": "Batch L2 transactions off-chain and verify validity proofs with gas compression analysis"
      },
      "privateTransfer": {
        "title": "Private Transfer",
        "description": "Shielded UTXO transfers with commitments, nullifiers, and double-spend prevention"
      }
    }
  },
  "appliedZk": {
    "pageTitle": "Applied ZK Proofs",
    "pageDescription": "Generate real zero-knowledge proofs in the browser using snarkjs, verify them on-chain with Groth16 verifiers",
    "beginner": "Beginner",
    "intermediate": "Intermediate",
    "advanced": "Advanced",
    "demos": {
      "hashPreimage": {
        "title": "Hash Preimage Proof",
        "description": "Prove you know a secret that hashes to a specific value without revealing it"
      },
      "ageVerification": {
        "title": "Age Verification",
        "description": "Prove your age meets a threshold without revealing your exact birthday"
      },
      "secretVoting": {
        "title": "Secret Voting",
        "description": "Cast anonymous votes verified by ZK proofs and Merkle tree membership"
      },
      "privateAirdrop": {
        "title": "Private Airdrop",
        "description": "Claim token airdrops privately using ZK proofs of Merkle tree inclusion"
      },
      "passwordProof": {
        "title": "Password Proof",
        "description": "Prove you know a password without revealing it. Uses salted Poseidon hashing for secure ZK authentication."
      },
      "sudoku": {
        "title": "Sudoku Verifier",
        "description": "Prove you solved a Sudoku puzzle correctly without revealing the solution. Demonstrates ZK for game verification."
      },
      "credential": {
        "title": "Credential Proof",
        "description": "Prove you hold a valid credential without revealing its details. Anonymous verification of qualifications."
      },
      "mastermind": {
        "title": "Mastermind Game",
        "description": "Play the classic code-breaking game with ZK-verified hints. Prove hint accuracy without revealing the secret code."
      },
      "mixer": {
        "title": "Privacy Mixer",
        "description": "Educational demonstration of private transactions. Deposit commitments and withdraw with ZK membership proofs."
      },
      "privateClub": {
        "title": "Private Club",
        "description": "Anonymous membership verification with tier-based access control. Prove your membership without revealing your identity."
      },
      "sealedAuction": {
        "title": "Sealed Bid Auction",
        "description": "Commit-reveal auction with ZK range proofs. Bid secretly and prove your bid is within valid bounds."
      },
      "proofAnimation": {
        "title": "Proof Animation",
        "description": "Watch the ZK proof lifecycle: witness generation, proof creation, and verification — animated step by step."
      },
      "circuitVisualization": {
        "title": "Circuit Visualization",
        "description": "Explore ZK circuit structure interactively — signals, constraints, and templates rendered as a node graph."
      }
    },
    "education": {
      "snark": {
        "title": "Understanding SNARKs",
        "description": "Learn how Succinct Non-interactive Arguments of Knowledge work, from trusted setup to proof verification.",
        "content": {
          "badge": "Education Module",
          "heading": "zk-SNARKs: Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge",
          "subtitle": "The most widely deployed zero-knowledge proof system in blockchain, powering Zcash, Tornado Cash, and numerous L2 solutions.",
          "tabs": {
            "overview": "Overview",
            "howItWorks": "How It Works",
            "trustedSetup": "Trusted Setup",
            "tryIt": "Try It"
          },
          "overview": {
            "whatIsTitle": "What is a zk-SNARK?",
            "whatIsDescription": "A zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) is a cryptographic proof that lets a prover convince a verifier that a statement is true without revealing any information beyond the validity of the statement itself. The acronym captures its key properties:",
            "zeroKnowledge": {
              "title": "Zero-Knowledge",
              "description": "The verifier learns nothing about the secret witness \u2014 only that it exists and satisfies the given constraints."
            },
            "succinct": {
              "title": "Succinct",
              "description": "Proofs are tiny (~200 bytes for Groth16) and can be verified in milliseconds regardless of the complexity of the original computation."
            },
            "nonInteractive": {
              "title": "Non-Interactive",
              "description": "A single message from prover to verifier \u2014 no back-and-forth needed. This makes on-chain verification practical."
            },
            "argumentOfKnowledge": {
              "title": "Argument of Knowledge",
              "description": "The prover must actually \u201cknow\u201d the secret witness. Computationally, it is infeasible to forge a valid proof without the real witness."
            },
            "advantages": {
              "title": "Advantages",
              "description": "Why SNARKs are widely adopted in blockchain",
              "item1": "Extremely small proof size (~200 bytes with Groth16)",
              "item2": "Constant-time verification (~10ms) regardless of circuit complexity",
              "item3": "Mature ecosystem: circom, snarkjs, Zcash, Ethereum support",
              "item4": "Gas-efficient on-chain verification (~200k gas on Ethereum)"
            },
            "limitations": {
              "title": "Limitations",
              "description": "Trade-offs to consider when choosing SNARKs",
              "item1": "Requires a trusted setup ceremony per circuit",
              "item2": "Not quantum-resistant \u2014 relies on elliptic curve pairings",
              "item3": "Circuit-specific: new setup needed for each different program",
              "item4": "Toxic waste from setup must be securely destroyed"
            }
          },
          "howItWorks": {
            "pipelineTitle": "SNARK Pipeline: From Statement to Proof",
            "pipelineDescription": "A SNARK proof goes through several mathematical transformations. Each step converts the computation into a form that is easier to prove and verify using elliptic curve cryptography.",
            "step1": {
              "title": "Write the Circuit (DSL)",
              "description": "Express the computation as an arithmetic circuit using a domain-specific language like circom.",
              "detail1": "Define private inputs (witness) and public inputs/outputs",
              "detail2": "Build constraints using addition and multiplication gates",
              "detail3": "The circuit is a DAG of arithmetic operations over a finite field"
            },
            "step2": {
              "title": "Compile to R1CS",
              "description": "The compiler converts the circuit into a Rank-1 Constraint System \u2014 a set of equations of the form A * B = C.",
              "detail1": "Each constraint involves linear combinations of variables",
              "detail2": "R1CS encodes the circuit as three matrices (A, B, C)",
              "detail3": "A valid witness satisfies all constraints simultaneously"
            },
            "step3": {
              "title": "Transform to QAP",
              "description": "The R1CS is interpolated into polynomials via a Quadratic Arithmetic Program.",
              "detail1": "Lagrange interpolation converts matrix rows into polynomials",
              "detail2": "Checking all constraints reduces to checking a polynomial identity",
              "detail3": "The key insight: polynomial identity testing is efficient via random evaluation"
            },
            "step4": {
              "title": "Generate the Proof",
              "description": "Using the proving key and the witness, compute elliptic curve points that encode the polynomial evaluations.",
              "detail1": "The prover evaluates polynomials at a secret point from the setup",
              "detail2": "Elliptic curve pairings enable verification without knowing the secret",
              "detail3": "The final proof consists of just 3 group elements (~200 bytes in Groth16)"
            },
            "exampleTitle": "Concrete Example",
            "example": {
              "label1": "1. Circuit (circom)",
              "label2": "2. R1CS Constraint",
              "label3": "3. What Gets Proven"
            }
          },
          "trustedSetup": {
            "ceremonyTitle": "The Trusted Setup Ceremony",
            "ceremonyDescription": "The trusted setup is the most controversial aspect of zk-SNARKs. It generates the proving key and verification key that the system needs, but the process produces \u201ctoxic waste\u201d that, if not destroyed, could be used to forge proofs.",
            "whatHappens": {
              "title": "What Happens",
              "item1": "A random secret \u03c4 (tau) is generated",
              "item2": "Powers of tau (\u03c4, \u03c4\u00b2, \u03c4\u00b3, ...) are computed",
              "item3": "These are encoded as elliptic curve points",
              "item4": "The result is the Structured Reference String (SRS)"
            },
            "toxicWaste": {
              "title": "Toxic Waste",
              "item1": "The raw value of \u03c4 must be destroyed",
              "item2": "If anyone retains \u03c4, they can forge proofs",
              "item3": "Multi-party ceremonies mitigate this risk",
              "item4": "Only ONE honest participant is needed for security"
            },
            "powersOfTau": {
              "title": "Powers of Tau Ceremony",
              "description": "Modern trusted setups use multi-party computation (MPC) to distribute trust. The Zcash Sapling ceremony had 87 participants; Ethereum\u2019s KZG ceremony had over 140,000.",
              "step1": {
                "title": "Phase 1: Universal Powers of Tau",
                "description": "Multiple participants each contribute randomness. Each one multiplies the previous result by their secret, then destroys it."
              },
              "step2": {
                "title": "Secure Destruction",
                "description": "Each participant securely deletes their random contribution. They may physically destroy the hardware used."
              },
              "step3": {
                "title": "Phase 2: Circuit-Specific Setup",
                "description": "The universal parameters are specialized for a particular circuit. This phase can also be a multi-party ceremony."
              }
            },
            "securityGuarantee": {
              "title": "1-of-N Security Guarantee",
              "description": "The ceremony is secure as long as at least one participant honestly destroys their secret contribution. With thousands of participants across the world, it is extremely unlikely that every single one is colluding."
            }
          },
          "tryIt": {
            "demoTitle": "Interactive zk-SNARK Demo",
            "whatHappenedTitle": "What Just Happened?",
            "whatHappenedDescription": "This simplified demo illustrates the core concept of zero-knowledge proofs. In a real SNARK:",
            "item1": "The proof is generated using elliptic curve cryptography, not simple arithmetic",
            "item2": "The verifier cannot extract the secret from the proof \u2014 even with unlimited computing power (computational soundness)",
            "item3": "Proofs can express far more complex statements (e.g., Sudoku solutions, credential checks, private transfers)",
            "item4": "On-chain verification costs ~200k gas and runs in constant time via the EVM precompile for pairing checks"
          }
        }
      },
      "stark": {
        "title": "Understanding STARKs",
        "description": "Explore Scalable Transparent Arguments of Knowledge — no trusted setup, hash-based security, quantum resistance.",
        "content": {
          "badge": "Education Module",
          "heading": "zk-STARKs: Scalable Transparent Arguments of Knowledge",
          "subheading": "The next generation of zero-knowledge proofs — no trusted setup, quantum-resistant security, and better scaling for large computations.",
          "tabs": {
            "overview": "Overview",
            "howItWorks": "How It Works",
            "fri": "FRI Protocol",
            "applications": "Applications"
          },
          "overview": {
            "whatIsTitle": "What is a zk-STARK?",
            "whatIsDescription": "A <strong>zk-STARK</strong> (Zero-Knowledge Scalable Transparent Argument of Knowledge) is a proof system invented by Eli Ben-Sasson and collaborators at StarkWare. STARKs solve two fundamental limitations of SNARKs: the need for a trusted setup and vulnerability to quantum computers.",
            "scalableTitle": "Scalable",
            "scalableDesc": "Proof generation time scales quasi-linearly with computation size, while verification time scales polylogarithmically. This means STARKs get relatively faster for larger programs.",
            "transparentTitle": "Transparent",
            "transparentDesc": "No trusted setup ceremony required. All randomness used in the proof is publicly verifiable, eliminating the \u201ctoxic waste\u201d problem entirely.",
            "quantumResistantTitle": "Quantum Resistant",
            "quantumResistantDesc": "STARKs rely only on collision-resistant hash functions (not elliptic curves), which are believed to resist quantum computer attacks.",
            "minimalAssumptionsTitle": "Minimal Assumptions",
            "minimalAssumptionsDesc": "Security rests on the existence of collision-resistant hash functions — one of the weakest and most well-studied cryptographic assumptions.",
            "advantagesTitle": "Advantages",
            "advantagesDesc": "Why STARKs are the future of proof systems",
            "adv1": "No trusted setup — fully transparent verification",
            "adv2": "Post-quantum secure (hash-based, no elliptic curves)",
            "adv3": "Better asymptotic scaling for very large computations",
            "adv4": "Prover time scales quasi-linearly: O(n log n)",
            "tradeoffsTitle": "Trade-offs",
            "tradeoffsDesc": "Where STARKs currently lag behind SNARKs",
            "trade1": "Larger proof size (~45 KB vs ~200 bytes for Groth16)",
            "trade2": "Slower on-chain verification (~100ms vs ~10ms)",
            "trade3": "Higher gas cost for Ethereum L1 verification",
            "trade4": "Ecosystem is younger with fewer developer tools"
          },
          "howItWorks": {
            "pipelineTitle": "STARK Pipeline: From Execution Trace to Proof",
            "pipelineDesc": "Instead of arithmetic circuits and R1CS, STARKs work with execution traces and algebraic constraints. The prover demonstrates that a sequence of computation steps satisfies given transition rules.",
            "step1Title": "Algebraic Intermediate Representation (AIR)",
            "step1Desc": "Express the computation as an execution trace with polynomial transition constraints.",
            "step1Detail1": "An execution trace is a table where each row is a computation step",
            "step1Detail2": "Transition constraints define rules between consecutive rows",
            "step1Detail3": "Boundary constraints fix values at specific positions (e.g., initial state)",
            "step2Title": "Polynomial Commitment",
            "step2Desc": "Interpolate the execution trace columns into polynomials and commit to them.",
            "step2Detail1": "Each column of the trace becomes a polynomial over a finite field",
            "step2Detail2": "Transition constraints become polynomial identity checks",
            "step2Detail3": "The composition polynomial combines all constraints into one check",
            "step3Title": "FRI Protocol",
            "step3Desc": "Use the Fast Reed-Solomon Interactive Oracle Proof to verify polynomial degree bounds.",
            "step3Detail1": "FRI iteratively reduces the polynomial degree by half",
            "step3Detail2": "Each round uses random challenges (via Fiat-Shamir in practice)",
            "step3Detail3": "At the end, the polynomial should be a constant (degree 0)",
            "step4Title": "Fiat-Shamir Transform",
            "step4Desc": "Convert the interactive protocol into a non-interactive proof by deriving challenges from a hash function.",
            "step4Detail1": "All verifier challenges are replaced by hash outputs",
            "step4Detail2": "The prover computes the hash of the transcript so far",
            "step4Detail3": "This makes the proof a single message (non-interactive)",
            "exampleTitle": "Example: Fibonacci Verification",
            "exampleDesc": "Suppose we want to prove we know the 100th Fibonacci number without revealing the full trace:",
            "executionTraceLabel": "Execution Trace",
            "transitionConstraintsLabel": "Transition Constraints"
          },
          "fri": {
            "title": "FRI: Fast Reed-Solomon IOP of Proximity",
            "description": "FRI is the core cryptographic protocol that makes STARKs work. It proves that a committed function is \u201cclose to\u201d a low-degree polynomial, which is the mathematical backbone for verifying computation integrity.",
            "howFriWorksTitle": "How FRI Works",
            "howFri1": "Start with a polynomial of degree d",
            "howFri2": "Split into even and odd coefficients",
            "howFri3": "Combine using a random challenge \u03b1",
            "howFri4": "The result has degree d/2 — repeat until degree 0",
            "whyTransparentTitle": "Why It's Transparent",
            "whyTransparent1": "All challenges derived from public hash functions",
            "whyTransparent2": "No secret parameters or trusted setup needed",
            "whyTransparent3": "Anyone can verify the proof independently",
            "whyTransparent4": "Security reduces to collision resistance of the hash",
            "postQuantumTitle": "Post-Quantum Security",
            "postQuantumDesc": "STARKs derive their security entirely from hash functions, which are believed to be resistant to quantum attacks. This is a significant advantage over SNARKs as quantum computing advances.",
            "starkSecurityTitle": "STARK Security Basis",
            "starkSecurity1": "Collision-resistant hash functions (SHA-256, Poseidon)",
            "starkSecurity2": "No elliptic curve assumptions",
            "starkSecurity3": "Grover's algorithm only halves hash security (128-bit \u2192 64-bit effective)",
            "snarkVulnerabilityTitle": "SNARK Vulnerability",
            "snarkVuln1": "Relies on elliptic curve discrete log problem",
            "snarkVuln2": "Shor's algorithm can break EC crypto in polynomial time",
            "snarkVuln3": "Would require migration to new proof systems",
            "futureProofingTitle": "Future-Proofing",
            "futureProofingDesc": "While practical quantum computers capable of breaking elliptic curves are still years away, choosing STARKs now provides a safety margin. Systems built on STARKs will not need to be migrated when quantum computing arrives.",
            "reductionTitle": "FRI Reduction Walkthrough",
            "reduceStep1Title": "Initial Polynomial (degree d)",
            "reduceStep1Desc": "Commit to evaluations of polynomial P(x) of degree d over a large evaluation domain.",
            "reduceStep2Title": "Split & Fold (degree d/2)",
            "reduceStep2Desc": "Decompose P(x) = P_even(x\u00b2) + x\u00b7P_odd(x\u00b2). Combine: P'(x) = P_even(x) + \u03b1\u00b7P_odd(x) using random challenge \u03b1.",
            "reduceStep3Title": "Repeat (degree d/4, d/8, ...)",
            "reduceStep3Desc": "Each round halves the degree. After log(d) rounds, the polynomial should be a constant.",
            "reduceStep4Title": "Final Check",
            "reduceStep4Desc": "Verify that the final claimed polynomial is indeed constant. The verifier spot-checks consistency between layers."
          },
          "applications": {
            "title": "Real-World STARK Applications",
            "description": "STARKs power some of the most ambitious projects in the blockchain space, particularly in L2 scaling and verifiable computation.",
            "starknetTitle": "StarkNet",
            "starknetDesc": "A permissionless decentralized ZK-Rollup on Ethereum using STARK proofs.",
            "starknetBadge1": "L2 Scaling",
            "starknetBadge2": "Cairo",
            "starknetBadge3": "Ethereum",
            "starknet1": "General-purpose smart contracts via Cairo language",
            "starknet2": "Validity proofs posted to Ethereum L1",
            "starknet3": "Account abstraction built-in from day one",
            "starkexTitle": "StarkEx",
            "starkexDesc": "A SaaS scaling engine used by dYdX, Immutable X, and Sorare.",
            "starkexBadge1": "dYdX",
            "starkexBadge2": "Immutable X",
            "starkexBadge3": "Sorare",
            "starkex1": "Processes 600K+ trades per day on dYdX",
            "starkex2": "Immutable X: gas-free NFT trading",
            "starkex3": "Batch proofs aggregate thousands of transactions",
            "midenTitle": "Polygon Miden",
            "midenDesc": "A STARK-based rollup by Polygon focused on privacy and programmability.",
            "midenBadge1": "Polygon",
            "midenBadge2": "Privacy",
            "midenBadge3": "Rollup",
            "miden1": "Client-side proof generation for privacy",
            "miden2": "Miden VM: a STARK-friendly virtual machine",
            "miden3": "Concurrent transaction execution",
            "riscZeroTitle": "RISC Zero",
            "riscZeroDesc": "A general-purpose zkVM that proves RISC-V execution using STARKs.",
            "riscZeroBadge1": "zkVM",
            "riscZeroBadge2": "RISC-V",
            "riscZeroBadge3": "Bonsai",
            "riscZero1": "Write ZK programs in Rust, C, or any RISC-V language",
            "riscZero2": "Bonsai network for remote proof generation",
            "riscZero3": "No circuit writing required — prove any program",
            "whenToUseTitle": "When to Use Each System",
            "chooseStarksTitle": "Choose STARKs when:",
            "chooseStarks1": "Large-scale computation (L2 rollups, VM execution)",
            "chooseStarks2": "Post-quantum security is a requirement",
            "chooseStarks3": "No trusted setup ceremony is acceptable",
            "chooseStarks4": "Prover scalability matters more than proof size",
            "chooseSnarksTitle": "Choose SNARKs when:",
            "chooseSnarks1": "On-chain verification cost must be minimized",
            "chooseSnarks2": "Small proof size is critical (e.g., on-chain storage)",
            "chooseSnarks3": "Mature tooling is needed (circom, snarkjs, Hardhat)",
            "chooseSnarks4": "Privacy applications (Zcash, Tornado Cash model)"
          }
        }
      },
      "comparison": {
        "title": "SNARK vs STARK",
        "description": "Compare the two major zero-knowledge proof systems across key metrics and use cases.",
        "content": {
          "badge": "Education Module",
          "heading": "SNARK vs STARK: A Comprehensive Comparison",
          "subheading": "Understand the key differences between the two dominant zero-knowledge proof systems and when to use each.",
          "stats": {
            "snarkProofSize": "SNARK Proof Size (bytes)",
            "starkProofSize": "STARK Proof Size (bytes)",
            "snarkVerificationTime": "SNARK Verification Time",
            "starkVerificationTime": "STARK Verification Time"
          },
          "quickOverview": {
            "title": "Quick Overview",
            "snark": {
              "description": "Succinct Non-interactive Argument of Knowledge. Uses elliptic curve pairings for extremely compact proofs.",
              "pro1": "Tiny proof size (~200 bytes)",
              "pro2": "Fast verification (~10ms)",
              "pro3": "Mature ecosystem (circom, snarkjs)",
              "con1": "Requires trusted setup",
              "con2": "Not quantum resistant"
            },
            "stark": {
              "description": "Scalable Transparent Argument of Knowledge. Uses hash functions for transparent, post-quantum security.",
              "pro1": "No trusted setup needed",
              "pro2": "Quantum resistant",
              "pro3": "Better scaling for large computations",
              "con1": "Larger proof size (~45 KB)",
              "con2": "Slower on-chain verification"
            }
          },
          "technicalComparison": {
            "title": "Technical Comparison",
            "aspect": "Aspect",
            "rows": {
              "cryptoBasis": {
                "label": "Cryptographic Basis",
                "snark": "Elliptic curve pairings",
                "stark": "Hash functions"
              },
              "trustedSetup": {
                "label": "Trusted Setup",
                "snark": "Required (per circuit)",
                "stark": "Not required"
              },
              "proofSize": {
                "label": "Proof Size",
                "snark": "~200 bytes",
                "stark": "~45 KB"
              },
              "verificationTime": {
                "label": "Verification Time",
                "snark": "~10ms (constant)",
                "stark": "~100ms (polylogarithmic)"
              },
              "proverComplexity": {
                "label": "Prover Complexity",
                "snark": "O(n log n)",
                "stark": "O(n polylog n)"
              },
              "verifierComplexity": {
                "label": "Verifier Complexity",
                "snark": "O(1)",
                "stark": "O(polylog n)"
              },
              "quantumResistance": {
                "label": "Quantum Resistance",
                "snark": "No",
                "stark": "Yes"
              },
              "gasCost": {
                "label": "On-chain Gas Cost",
                "snark": "~200K gas",
                "stark": "~1M+ gas"
              }
            }
          },
          "useCases": {
            "title": "Best Use Cases",
            "snark": {
              "heading": "Best for SNARKs",
              "onChain": {
                "title": "On-chain Verification",
                "description": "When gas cost is the primary constraint (privacy protocols, credential verification, on-chain games)"
              },
              "privacy": {
                "title": "Privacy Applications",
                "description": "Zcash, Tornado Cash model \u2014 where small proof size enables efficient private transactions"
              },
              "identity": {
                "title": "Identity & Credentials",
                "description": "Prove properties about your identity (age, membership) without revealing the underlying data"
              },
              "tooling": {
                "title": "Rich Tooling Needed",
                "description": "Projects that need mature developer tools, audited libraries, and community support"
              }
            },
            "stark": {
              "heading": "Best for STARKs",
              "rollups": {
                "title": "L2 Rollups",
                "description": "StarkNet, StarkEx \u2014 batch thousands of transactions into a single proof posted to L1"
              },
              "largeComputation": {
                "title": "Large Computations",
                "description": "Complex VM execution, ML inference verification, and computations with millions of constraints"
              },
              "longTermSecurity": {
                "title": "Long-term Security",
                "description": "Systems that need to remain secure for decades, even against future quantum computers"
              },
              "noTrust": {
                "title": "No Trust Required",
                "description": "Environments where any form of trusted setup is unacceptable (government, critical infrastructure)"
              }
            }
          },
          "future": {
            "title": "The Future: Convergence",
            "intro": "The line between SNARKs and STARKs is blurring as researchers develop hybrid approaches that combine the best of both worlds.",
            "wrapping": {
              "title": "STARK \u2192 SNARK Wrapping",
              "description": "Generate a STARK proof for the computation, then wrap it in a SNARK for cheap on-chain verification. StarkNet already does this with SHARP."
            },
            "universalSnarks": {
              "title": "Universal SNARKs",
              "description": "Systems like PLONK and Halo 2 eliminate circuit-specific setup with a universal SRS, reducing the trusted setup burden."
            },
            "recursiveProofs": {
              "title": "Recursive Proofs",
              "description": "A proof that verifies another proof. This enables incremental verification and proof aggregation across both SNARK and STARK systems."
            },
            "bottomLine": {
              "title": "The Bottom Line",
              "description": "Neither SNARKs nor STARKs are universally \u201cbetter.\u201d The right choice depends on your constraints: proof size, setup trust model, quantum resistance, and computation scale. The industry is converging toward hybrid solutions that leverage the strengths of both systems."
            }
          }
        }
      }
    },
    "visualization": {
      "circuit": {
        "title": "Circuit Visualization",
        "description": "Explore interactive circuit graphs used in zero-knowledge proofs. Understand signal flow and constraints."
      },
      "proof": {
        "title": "Proof Animation",
        "description": "Watch the ZK proof generation pipeline in action. Visualize Input → Witness → Proof → Verify steps."
      },
      "comparison": {
        "title": "SNARK vs STARK",
        "description": "Compare SNARK and STARK proof systems across key metrics like proof size, verification time, and quantum resistance."
      }
    }
  },
  "visualization": {
    "circuit": {
      "circuitSelect": { "placeholder": "Select a circuit" },
      "legend": {
        "title": "Legend",
        "inputSignal": "Input Signal",
        "outputSignal": "Output Signal",
        "intermediateSignal": "Intermediate Signal",
        "constraint": "Constraint",
        "templateComponent": "Template Component"
      },
      "nodeInfo": {
        "selectedNode": "Selected Node",
        "visibility": "Visibility"
      }
    },
    "circuits": {
      "multiplier": {
        "name": "Multiplier",
        "description": "Simple multiplication circuit: a × b = c"
      },
      "rangeCheck": {
        "name": "Range Check",
        "description": "Verify a number is within N bits using binary decomposition"
      },
      "voting": {
        "name": "Anonymous Voting",
        "description": "Verify membership and cast a vote without revealing identity"
      }
    },
    "circuitNodes": {
      "decomposeToBits": "Decompose value into binary bits",
      "binaryCheck": "Ensure each bit is 0 or 1",
      "hashIdentity": "Hash identity secret with Poseidon",
      "verifyMembership": "Verify Merkle tree membership",
      "nullifierHash": "Generate unique nullifier hash",
      "binaryVote": "Ensure vote is binary (0 or 1)"
    },
    "proof": {
      "pipelineTitle": "Proof Pipeline",
      "buttons": {
        "start": "Start",
        "pause": "Pause",
        "resume": "Resume",
        "restart": "Restart"
      },
      "steps": {
        "input": { "name": "Prepare Inputs", "description": "Gather and validate circuit inputs" },
        "witness": { "name": "Compute Witness", "description": "Calculate all intermediate signals" },
        "proof": { "name": "Generate Proof", "description": "Create the zero-knowledge proof" },
        "verify": { "name": "Verify Proof", "description": "Validate the proof against public inputs" }
      },
      "status": {
        "complete": "Complete",
        "inProgress": "In Progress"
      },
      "proofVerified": {
        "title": "Proof Verified!",
        "description": "The zero-knowledge proof was successfully verified."
      }
    },
    "proofStats": {
      "proofSize": "Proof Size",
      "verificationTime": "Verification Time",
      "proofGeneration": "Proof Generation",
      "publicSignals": "Public Signals"
    },
    "comparison": {
      "chartTitle": "SNARK vs STARK Comparison",
      "loadingChart": "Loading chart...",
      "barChart": "Bar Chart",
      "radarChart": "Radar Chart",
      "chartNote": "Values are normalized for comparison. Higher is better for each metric.",
      "detailedComparison": "Detailed Comparison",
      "tableHeaders": {
        "aspect": "Aspect",
        "snark": "zk-SNARK",
        "stark": "zk-STARK"
      }
    },
    "comparisonCategories": {
      "proofSize": "Proof Size",
      "verificationTime": "Verification Time",
      "proverTime": "Prover Time",
      "setupRequired": "Trusted Setup",
      "quantumSafe": "Quantum Safe"
    },
    "comparisonTable": {
      "proofSize": {
        "aspect": "Proof Size",
        "snark": "~200 bytes",
        "stark": "~45 KB",
        "description": "Size of the generated proof data"
      },
      "verificationTime": {
        "aspect": "Verification Time",
        "snark": "~10 ms",
        "stark": "~100 ms",
        "description": "Time to verify a proof on-chain"
      },
      "proverTime": {
        "aspect": "Prover Time",
        "snark": "Slower",
        "stark": "Faster",
        "description": "Time to generate the proof"
      },
      "trustedSetup": {
        "aspect": "Trusted Setup",
        "snark": "Required",
        "stark": "Not Required",
        "description": "Whether a trusted ceremony is needed"
      },
      "quantumResistance": {
        "aspect": "Quantum Resistance",
        "snark": "Not Resistant",
        "stark": "Resistant",
        "description": "Security against quantum computers"
      },
      "ecosystemMaturity": {
        "aspect": "Ecosystem Maturity",
        "snark": "Mature",
        "stark": "Growing",
        "description": "Tooling, libraries, and adoption level"
      }
    }
  },
  "nav": {
    "home": "Home",
    "fundamentals": "Fundamentals",
    "defi": "DeFi",
    "solidity": "Solidity",
    "tokens": "Tokens",
    "zk": "ZK Proofs",
    "appliedZk": "Applied ZK"
  }
}
