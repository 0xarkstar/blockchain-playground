/**
 * Finite Field Arithmetic — shared by most ZK demos.
 *
 * Uses a pedagogical small prime field (p = 23) so every value fits in a
 * human-readable table.  Real ZK uses elliptic-curve groups with 256-bit
 * primes; each demo's educational notes explain this.
 */

// ── Types ──────────────────────────────────────────────────────────────

export interface FieldParams {
  readonly p: bigint; // prime modulus
  readonly g: bigint; // generator
  readonly q: bigint; // order of <g>
}

// ── Core modular operations ────────────────────────────────────────────

export function modAdd(a: bigint, b: bigint, p: bigint): bigint {
  return ((a % p) + (b % p) + p + p) % p;
}

export function modSub(a: bigint, b: bigint, p: bigint): bigint {
  return ((a % p) - (b % p) + p + p) % p;
}

export function modMul(a: bigint, b: bigint, p: bigint): bigint {
  return ((a % p) * (b % p) + p * p) % p;
}

export function modPow(base: bigint, exp: bigint, p: bigint): bigint {
  let result = 1n;
  let b = ((base % p) + p) % p;
  let e = exp;
  if (e < 0n) {
    b = modInverse(b, p);
    e = -e;
  }
  while (e > 0n) {
    if (e & 1n) result = (result * b) % p;
    b = (b * b) % p;
    e >>= 1n;
  }
  return result;
}

/** Extended Euclidean algorithm → modular inverse (throws if gcd ≠ 1). */
export function modInverse(a: bigint, p: bigint): bigint {
  let [old_r, r] = [((a % p) + p) % p, p];
  let [old_s, s] = [1n, 0n];
  while (r !== 0n) {
    const q = old_r / r;
    [old_r, r] = [r, old_r - q * r];
    [old_s, s] = [s, old_s - q * s];
  }
  if (old_r !== 1n) throw new Error(`No inverse: gcd(${a}, ${p}) ≠ 1`);
  return ((old_s % p) + p) % p;
}

// ── Field constructors ─────────────────────────────────────────────────

/**
 * Full multiplicative group Z*₂₃  (order 22).
 * g = 5 is a primitive root, so <5> generates all of Z*₂₃.
 */
export function getSmallPrimeField(): FieldParams {
  return { p: 23n, g: 5n, q: 22n };
}

/**
 * Schnorr-friendly subgroup of Z*₂₃.
 * g = 2, order q = 11  (verified: 2¹¹ mod 23 = 1).
 * Used for Schnorr identification, Pedersen commitments, etc.
 */
export function getSchnorrField(): FieldParams {
  return { p: 23n, g: 2n, q: 11n };
}

// ── Helpers ────────────────────────────────────────────────────────────

/** Pseudo-random field element in [1, max). */
export function randomFieldElement(max: bigint): bigint {
  if (max <= 1n) return 0n;
  const range = Number(max - 1n);
  return BigInt(Math.floor(Math.random() * range)) + 1n;
}

/** List all elements generated by g in Z*_p. */
export function listGroupElements(g: bigint, p: bigint): bigint[] {
  const elems: bigint[] = [];
  let current = g % p;
  do {
    elems.push(current);
    current = (current * g) % p;
  } while (current !== g % p && elems.length < Number(p));
  return elems;
}

/** Order of g in Z*_p  (smallest k > 0 with g^k ≡ 1). */
export function elementOrder(g: bigint, p: bigint): bigint {
  let k = 1n;
  let current = g % p;
  while (current !== 1n && k < p) {
    current = (current * g) % p;
    k++;
  }
  return k;
}
