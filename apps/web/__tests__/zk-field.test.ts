import { describe, it, expect } from "vitest";
import {
  modAdd,
  modSub,
  modMul,
  modPow,
  modInverse,
  getSmallPrimeField,
  getSchnorrField,
  randomFieldElement,
  listGroupElements,
  elementOrder,
} from "../lib/zk/field";

describe("Finite Field Arithmetic", () => {
  const p = 23n;

  describe("modAdd", () => {
    it("adds within modulus", () => {
      expect(modAdd(10n, 5n, p)).toBe(15n);
    });
    it("wraps around", () => {
      expect(modAdd(20n, 10n, p)).toBe(7n);
    });
    it("handles zero", () => {
      expect(modAdd(0n, 0n, p)).toBe(0n);
    });
    it("handles negative inputs", () => {
      expect(modAdd(-1n, 1n, p)).toBe(0n);
    });
  });

  describe("modSub", () => {
    it("subtracts normally", () => {
      expect(modSub(10n, 5n, p)).toBe(5n);
    });
    it("wraps negative to positive", () => {
      expect(modSub(5n, 10n, p)).toBe(18n);
    });
  });

  describe("modMul", () => {
    it("multiplies within modulus", () => {
      expect(modMul(3n, 4n, p)).toBe(12n);
    });
    it("wraps around", () => {
      expect(modMul(5n, 5n, p)).toBe(2n);
    });
    it("multiply by zero", () => {
      expect(modMul(0n, 5n, p)).toBe(0n);
    });
  });

  describe("modPow", () => {
    it("computes small powers", () => {
      expect(modPow(2n, 3n, p)).toBe(8n);
    });
    it("wraps large powers", () => {
      expect(modPow(2n, 10n, p)).toBe(1024n % p);
    });
    it("x^0 = 1", () => {
      expect(modPow(5n, 0n, p)).toBe(1n);
    });
    it("Fermat's little theorem: a^(p-1) â‰¡ 1", () => {
      expect(modPow(5n, 22n, p)).toBe(1n);
    });
    it("Schnorr subgroup: 2^11 mod 23 = 1", () => {
      expect(modPow(2n, 11n, p)).toBe(1n);
    });
  });

  describe("modInverse", () => {
    it("finds inverse", () => {
      const inv = modInverse(5n, p);
      expect(modMul(5n, inv, p)).toBe(1n);
    });
    it("inverse of 1 is 1", () => {
      expect(modInverse(1n, p)).toBe(1n);
    });
    it("throws for non-coprime", () => {
      expect(() => modInverse(0n, p)).toThrow();
    });
  });

  describe("getSmallPrimeField", () => {
    it("returns p=23, g=5, q=22", () => {
      const field = getSmallPrimeField();
      expect(field.p).toBe(23n);
      expect(field.g).toBe(5n);
      expect(field.q).toBe(22n);
    });
    it("g is a primitive root", () => {
      const field = getSmallPrimeField();
      expect(elementOrder(field.g, field.p)).toBe(field.q);
    });
  });

  describe("getSchnorrField", () => {
    it("returns p=23, g=2, q=11", () => {
      const field = getSchnorrField();
      expect(field.p).toBe(23n);
      expect(field.g).toBe(2n);
      expect(field.q).toBe(11n);
    });
    it("g has order q", () => {
      const field = getSchnorrField();
      expect(modPow(field.g, field.q, field.p)).toBe(1n);
    });
  });

  describe("randomFieldElement", () => {
    it("returns value in [1, max)", () => {
      for (let i = 0; i < 20; i++) {
        const val = randomFieldElement(10n);
        expect(val).toBeGreaterThanOrEqual(1n);
        expect(val).toBeLessThan(10n);
      }
    });
    it("returns 0 for max <= 1", () => {
      expect(randomFieldElement(1n)).toBe(0n);
    });
  });

  describe("listGroupElements", () => {
    it("lists elements generated by g=2 mod 23", () => {
      const elems = listGroupElements(2n, 23n);
      expect(elems.length).toBe(11);
      expect(elems[0]).toBe(2n);
    });
    it("lists all 22 elements for g=5 (primitive root)", () => {
      const elems = listGroupElements(5n, 23n);
      expect(elems.length).toBe(22);
    });
  });

  describe("elementOrder", () => {
    it("order of 2 mod 23 is 11", () => {
      expect(elementOrder(2n, 23n)).toBe(11n);
    });
    it("order of 5 mod 23 is 22", () => {
      expect(elementOrder(5n, 23n)).toBe(22n);
    });
    it("order of 1 mod 23 is 1", () => {
      expect(elementOrder(1n, 23n)).toBe(1n);
    });
  });
});
